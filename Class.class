;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: This is the base class, which every   ;
; class inherits from...                             ;
;                                                    ;
; Usage: $Class(<uID>,<Params>,...).<Member>         ;
; Example: var %x $Class                             ;
; Example: $Class(%x,Name,Some Text).SET             ;
; Example: $Class(%x,Name).GET                       ;
; Example: $Class(%x,Name).UNSET                     ;
; Example: $Class(%x).FREE                           ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;
; Class Header ;
;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;
; Public Declarations ;
;;;;;;;;;;;;;;;;;;;;;;;
alias Class.FREE.Public

alias Class.GET.Public

alias Class.SET.Public
alias Class.UNSET.Public

alias Class.EXPORT.Public
alias Class.IMPORT.Public
alias Class.CLONE.Public

;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exception Declarations ;
;;;;;;;;;;;;;;;;;;;;;;;;;;
alias Class.EXCEPTION.Null {
  var %params $1, %object $2, %error $3, %message $6, %scriptLine $4, %scriptDir $5
  UNMAKETOK
  + Exception Caught on line $+($chr(40),%scriptLine,:,%scriptDir,$chr(41)) from Object ( $+ %object $+ : $+ $IsInstance(%object) $+ ): %error $+  - %message
  return $null
}
alias Class.EXCEPTION.NoOperation {
  var %params $1, %object $2, %error $3, %message $6, %scriptLine $4, %scriptDir $5
  UNMAKETOK
  + Exception Caught on line $+($chr(40),%scriptLine,:,%scriptDir,$chr(41)) from Object ( $+ %object $+ : $+ $IsInstance(%object) $+ ): %error $+  - %message
  return $null
}
alias Class.EXCEPTION.MemberErr {
  var %params $1, %object $2, %error $3, %message $6, %scriptLine $4, %scriptDir $5
  UNMAKETOK
  + Exception Caught on line $+($chr(40),%scriptLine,:,%scriptDir,$chr(41)) from Object ( $+ %object $+ : $+ $IsInstance(%object) $+ ): %error $+  - %message
  return $null
}

alias Class.EXCEPTION.ParamErr {
  var %params $1, %object $2, %error $3, %message $6, %scriptLine $4, %scriptDir $5
  + Exception Caught on line $+($chr(40),%scriptLine,:,%scriptDir,$chr(41)) from Object ( $+ %object $+ : $+ $IsInstance(%object) $+ ): %error $+  - %message
  return $null
}
alias Class.EXCEPTION.RangeErr {
  var %params $1, %object $2, %error $3, %message $6, %scriptLine $4, %scriptDir $5
  UNMAKETOK
  + Exception Caught on line $+($chr(40),%scriptLine,:,%scriptDir,$chr(41)) from Object ( $+ %object $+ : $+ $IsInstance(%object) $+ ): %error $+  - %message
  return $null
}
;;;;;;;;;;;;;;;;;;;;;;;
; Main Class Function ;
;;;;;;;;;;;;;;;;;;;;;;;
alias Class {
  var %class Class
  var %prop $mprop($prop)
  if !$mprop($prop) {
    if ($IsPrivate(%class,INIT)) {

      var %astart $MAKETOKCOUNT
      MAKETOK Class
      MAKETOK INIT
      var %aend $MAKETOKCOUNT

      var %bstart $MAKETOKCOUNT
      var %bend $MAKETOKCOUNT

      var %cstart $MAKETOKCOUNT + 1
      MAKETOK $*
      var %cend $MAKETOKCOUNT

      var %dstart $MAKETOKCOUNT
      ; For what ever comes after the tokens
      var %dend $MAKETOKCOUNT

      var %object $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
      - $inheritsFrom(%object,%class)
      UNMAKETOK
      return %object
    }
    UNMAKETOK
  }
  else if $IsPublic(%class,$fprop($mprop($prop))) {
    var %object $1

    var %astart $MAKETOKCOUNT
    MAKETOK Class
    MAKETOK $prop
    MAKETOK %object
    var %aend $MAKETOKCOUNT

    var %bstart $MAKETOKCOUNT
    ;;MAKETOK $fprop($mprop($prop), 2-)
    MAKETOK %object
    var %bend $MAKETOKCOUNT

    var %cstart $MAKETOKCOUNT + 2
    MAKETOK $*
    var %cend $MAKETOKCOUNT

    var %dstart $MAKETOKCOUNT
    ; For what ever comes after the tokens
    var %dend $MAKETOKCOUNT

    return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
  }
  else {
    UNMAKETOK
    if $isinstance($1) {
      return $catch($1,MemberErr, $scriptline, $token($token($script,-1,92),1,46), $qt($fprop($mprop($prop))) is not a public member of class $qt(%Class))
    }
    else {
      return $catch(%class,MemberErr, $scriptline, $token($token($script,-1,92),1,46), $qt($fprop($mprop($prop))) is not a public member of class $qt(%Class)).class  
    }
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initialization Function ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias -l Class.INIT {
  var %params $1
  var %htable MSL++
  hinc -m %htable OBJECT_NUMBER
  var %object $+(%htable,_,$hget(%htable,OBJECT_NUMBER)) 

  hadd -m %htable $+(%object,_,INIT)
  return %object
}
;;;;;;;;;;;;;;;;;;;;
; END CLASS HEADER ;
;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;
; Class Body ;
;;;;;;;;;;;;;;
alias -l Class.SET {
  var %params $1
  var %object $2
  var %variable $3
  var %value $4
  if (!$IsInstanceOf(%object, Class)) {
    UNMAKETOK
    if ($isInstance(%object)) {
      return $catch(%object, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%object) is not an instance of class $qt(Class))
    }
    else {
      return $catch(Class, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%object) is not an instance of class $qt(Class)).class
    }
  }
  if %variable != $null {
    if %value != $null {
      if $cprop(%params,BVAR) || $cprop(%params, B) {
        hadd -mb %object %variable %value

        if $prop {
          var %astart $MAKETOKCOUNT
          MAKETOK Class
          MAKETOK $prop
          MAKETOK %object
          MAKETOK $cprop(%params,IS_OBJECT_CALL)
          var %aend $MAKETOKCOUNT

          var %bstart $MAKETOKCOUNT
          ;MAKETOK %object
          var %bend $MAKETOKCOUNT

          var %cstart $MAKETOKCOUNT + 5
          MAKETOK $*
          var %cend $MAKETOKCOUNT

          var %dstart $MAKETOKCOUNT
          ; For what ever comes after the tokens
          var %dend $MAKETOKCOUNT

          return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
        }
      }
      else {
        hadd -m %object %variable %value
        if $prop {
          var %astart $MAKETOKCOUNT
          MAKETOK Class
          MAKETOK $prop
          MAKETOK %object
          MAKETOK $cprop(%params,IS_OBJECT_CALL)
          var %aend $MAKETOKCOUNT

          var %bstart $MAKETOKCOUNT
          ;MAKETOK %object
          var %bend $MAKETOKCOUNT

          var %cstart $MAKETOKCOUNT + 5
          MAKETOK $*
          var %cend $MAKETOKCOUNT

          var %dstart $MAKETOKCOUNT
          ; For what ever comes after the tokens
          var %dend $MAKETOKCOUNT

          return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
        }
      }
    }
    else {
      UNMAKETOK
      return $catch(%object,ParamErr,$scriptline, $token($token($script,-1,92),1,46), there is no value specified for this set call!)
    }
  }
  else {
    UNMAKETOK
    return $catch(%object,ParamErr,$scriptline, $token($token($script,-1,92),1,46), there is no variable specified for this set call!)
  }
  UNMAKETOK
}

alias -l Class.GET {
  var %params $1
  var %object $2
  var %variableName $3
  var %bvar $4
  var %hget

  if (!$IsInstanceOf(%object, Class)) {
    UNMAKETOK
    if ($isInstance(%object)) {
      return $catch(%Object, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%object) is not an instance of class $qt(Class))
    }
    else {
      return $catch(Class, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%object) is not an instance of class $qt(Class)).class
    }
  }

  if $cprop(%params,BVAR) || $cprop(%params,B) {
    if $cprop(%params,ITEM) {
      if (%variableName isnum 1 - $hget(%object,0).item) {
        var %hget $hget(%object,%variableName, %bvar).item
      }
      else {
        UNMAKETOK
        return $catch(%object,RangeErr,$scriptline, $token($token($script,-1,92),1,46),$qt(%variableName) is not a valid index for object $qt(%object) $+ . Valid Ranges: 1- $+ $hget(%object, 0).item)
      }
    }
    else {
      var %hget $hget(%object,%variableName,%bvar)
    }
    if $prop {
      var %astart $MAKETOKCOUNT
      MAKETOK Class
      MAKETOK $prop
      MAKETOK %object
      MAKETOK $cprop(%params,IS_OBJECT_CALL)
      var %aend $MAKETOKCOUNT

      var %bstart $MAKETOKCOUNT
      ;MAKETOK %object
      $iif($cprop(%params,stack),MAKETOK %bvar)
      var %bend $MAKETOKCOUNT

      var %cstart $MAKETOKCOUNT + 5
      MAKETOK $*
      $iif(!$cprop(%params,stack), MAKETOK %bvar)
      var %cend $MAKETOKCOUNT

      var %dstart $MAKETOKCOUNT
      ; For what ever comes after the tokens
      var %dend $MAKETOKCOUNT

      return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)

    }
    UNMAKETOK
    return %hget
  }
  else {
    var %hget
    if $cprop(%params, ITEM) {
      if (%variableName isnum 1 - $hget(%object,0).item) {
        var %hget $hget(%object,%variableName).item
      }
      else {
        return $catch(%object,RangeErr,$scriptline, $token($token($script,-1,92),1,46),$qt(%variableName) is not a valid index for object $qt(%object) $+ . Valid Ranges: 1- $+ $hget(%object, 0).item)
      }
    }
    else {
      if ($hget(%object,%variableName) == $null) {
        return $catch(%object,MemberErr,$scriptline,$token($token($script,-1,92),1,46),$qt(%variableName) is not a valid member of object $qt(%object))
      }
      else {
        var %hget $hget(%object,%variableName)
        if $prop {
          var %astart $MAKETOKCOUNT
          MAKETOK Class
          MAKETOK $prop
          MAKETOK %object
          MAKETOK $cprop(%params,IS_OBJECT_CALL)
          var %aend $MAKETOKCOUNT

          var %bstart $MAKETOKCOUNT
          ;MAKETOK %object
          $iif($cprop(%params,STACK),MAKETOK %hget)
          var %bend $MAKETOKCOUNT


          var %cstart $MAKETOKCOUNT + 4
          MAKETOK $*
          $iif(!$cprop(%params,STACK), MAKETOK %hget)
          var %cend $MAKETOKCOUNT

          var %dstart $MAKETOKCOUNT
          ; For what ever comes after the tokens
          var %dend $MAKETOKCOUNT

          return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
        }
      }
    }
  }
  UNMAKETOK
  return %hget
}

alias -l Class.UNSET {
  var %params $1
  var %object $2

  if (!$IsInstanceOf(%object, Class)) {
    UNMAKETOK
    if ($isInstance(%object)) {
      return $catch(%Object, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%object) is not an instance of class $qt(Class))
    }
    else {
      return $catch(Class, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%object) is not an instance of class $qt(Class)).class
    }
  }

  ;;TODO CHECK FOR 'ITEM' IN PARAMS
  hdel %object $$3

  if $prop {
    var %astart $MAKETOKCOUNT
    MAKETOK Class
    MAKETOK $prop
    MAKETOK %object
    MAKETOK $cprop(%params,IS_OBJECT_CALL)
    var %aend $MAKETOKCOUNT


    var %bstart $MAKETOKCOUNT
    ;MAKETOK %object
    var %bend $MAKETOKCOUNT


    var %cstart $MAKETOKCOUNT + 4
    MAKETOK $*
    var %cend $MAKETOKCOUNT

    var %dstart $MAKETOKCOUNT
    ; For what ever comes after the tokens
    var %dend $MAKETOKCOUNT

    return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
  }
  UNMAKETOK
}


alias -l Class_FREE_STACK {
  if !$hfind(CLASS_FREE_STACK, $1-) {
    hadd -m CLASS_FREE_STACK $1- 1
    return 1
  }
  return 0
}
alias -l Class.FREE {
  ;;;;;;;;;;;;;;;;;;;;;;
  ; Do Destroying here ;
  ;;;;;;;;;;;;;;;;;;;;;;
  ;;TODO CHECK FOR 'ITEM' IN PARAMS
  var %params $1
  var %object $2
  var %depth $3
  var %prop $mprop($prop)

  if (!$IsInstanceOf(%object, Class)) {
    UNMAKETOK
    if ($isInstance(%object)) {
      return $catch(%Object, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%object) is not an instance of class $qt(Class))
    }
    else {
      return $catch(Class, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%object) is not an instance of class $qt(Class)).class
    }
  }

  if $cprop(%params,ALL) || $cprop(%params,A) {
    if $hget(%object) {
      var %y $hget(%object,0).item
      while %y {
        var %currentObject $hget(%object, $hget(%object,%y).ITEM)

        var %astart $MAKETOKCOUNT
        MAKETOK Class
        MAKETOK FREE:ALL
        MAKETOK %object
        MAKETOK $cprop(%params,IS_OBJECT_CALL)
        var %aend $MAKETOKCOUNT

        var %bstart $MAKETOKCOUNT
        MAKETOK %currentObject
        var %bend $MAKETOKCOUNT

        var %cstart $MAKETOKCOUNT + 3
        MAKETOK $*
        var %cend $MAKETOKCOUNT

        var %dstart $MAKETOKCOUNT
        ; For what ever comes after the tokens
        var %dend $MAKETOKCOUNT

        if $CLASS_FREE_STACK(%currentObject) {
          - $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
        }
        dec %y
      }
      if ($hget(CLASS_FREE_STACK)) hfree CLASS_FREE_STACK
    }
  }
  if ($hget(MSL++,%object $+ _INIT)) hdel MSL++ %object $+ _INIT
  if ($hget(%object)) hfree %object 
  UNMAKETOK
  if $prop {
    var %astart $MAKETOKCOUNT
    MAKETOK Class
    MAKETOK $prop
    MAKETOK %object
    MAKETOK $cprop(%params,IS_OBJECT_CALL)
    var %aend $MAKETOKCOUNT

    var %bstart $MAKETOKCOUNT
    MAKETOK %object
    var %bend $MAKETOKCOUNT

    var %cstart $MAKETOKCOUNT + 3
    MAKETOK $*
    var %cend $MAKETOKCOUNT

    var %dstart $MAKETOKCOUNT
    ; For what ever comes after the tokens
    var %dend $MAKETOKCOUNT

    return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
  } 
}

alias -l Class.IMPORT {
  var %params $1
  var %objectDir $mircdir $+ MSL++
  var %objectName $2

  if !$exists(%objectDir) { mkdir %objectDir }
  if $hget(%objectName) { return }
  hmake %objectName
  hload -b %objectName $+(%objectDir,\,%objectName,.obj)
  if $hget(%objectName) { 
    if $prop {
      var %astart $MAKETOKCOUNT
      MAKETOK Class
      MAKETOK $prop
      MAKETOK %objectName
      MAKETOK $cprop(%params,IS_OBJECT_CALL)
      var %aend $MAKETOKCOUNT

      var %bstart $MAKETOKCOUNT
      MAKETOK %objectName
      var %bend $MAKETOKCOUNT

      var %cstart $MAKETOKCOUNT + 3
      MAKETOK $*
      var %cend $MAKETOKCOUNT

      var %dstart $MAKETOKCOUNT
      ; For what ever comes after the tokens
      var %dend $MAKETOKCOUNT

      return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)

    }
  }
  if $prop {
    var %astart $MAKETOKCOUNT
    MAKETOK Class
    MAKETOK $prop
    MAKETOK %objectName
    MAKETOK $cprop(%params,IS_OBJECT_CALL)
    var %aend $MAKETOKCOUNT

    var %bstart $MAKETOKCOUNT
    MAKETOK %objectName
    var %bend $MAKETOKCOUNT

    var %cstart $MAKETOKCOUNT + 3
    MAKETOK $*
    var %cend $MAKETOKCOUNT

    var %dstart $MAKETOKCOUNT
    ; For what ever comes after the tokens
    var %dend $MAKETOKCOUNT

    return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
  }
  UNMAKETOK
}

alias -l Class.EXPORT {
  var %params $1
  var %objectDir $mircdir $+ MSL++
  var %objectName $2

  if (!$IsInstanceOf(%objectName, Class)) {
    UNMAKETOK
    if ($isInstance(%objectName)) {
      return $catch(%objectName, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%objectName) is not an instance of class $qt(Class))
    }
    else {
      return $catch(Class, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%objectName) is not an instance of class $qt(Class)).class
    }
  }

  if !$exists(%objectDir) { mkdir %objectDir }
  hsave -b %objectName $+(%objectDir,\,%objectName $+ .obj)
  if $prop {
    var %astart $MAKETOKCOUNT
    MAKETOK Class
    MAKETOK $prop
    MAKETOK %objectName
    MAKETOK $cprop(%params,IS_OBJECT_CALL)
    var %aend $MAKETOKCOUNT


    var %bstart $MAKETOKCOUNT
    MAKETOK %objectName
    var %bend $MAKETOKCOUNT

    var %cstart $MAKETOKCOUNT + 3
    MAKETOK $*
    var %cend $MAKETOKCOUNT

    var %dstart $MAKETOKCOUNT
    ; For what ever comes after the tokens
    var %dend $MAKETOKCOUNT

    return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
  }
  UNMAKETOK
}

alias -l Class.CLONE {
  var %params $1
  var %objectDir $mircdir $+ MSL++
  var %objectName $2

  if (!$IsInstanceOf(%objectName, Class)) {
    UNMAKETOK
    if ($isInstance(%objectName)) {
      return $catch(%objectName, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%objectName) is not an instance of class $qt(Class))
    }
    else {
      return $catch(Class, Null, $scriptline, $token($token($script,-1,92),1,46), object $qt(%objectName) is not an instance of class $qt(Class)).class
    }
  }

  if !$exists(%objectDir) { mkdir %objectDir }

  var %object $Class
  hsave -b %objectName $+(%objectDir,\,%objectName,.cpy)

  hload -mb %object $+(%objectDir,\,%objectName,.cpy)

  .remove $+(%objectDir,\,%objectName,.cpy)
  UNMAKETOK
  return %object

  if $prop {
    var %astart $MAKETOKCOUNT
    MAKETOK Class
    MAKETOK $prop
    MAKETOK %objectName
    MAKETOK $cprop(%params,IS_OBJECT_CALL)
    var %aend $MAKETOKCOUNT

    var %bstart $MAKETOKCOUNT
    MAKETOK %objectName
    var %bend $MAKETOKCOUNT

    var %cstart $MAKETOKCOUNT + 3
    MAKETOK $*
    var %cend $MAKETOKCOUNT

    var %dstart $MAKETOKCOUNT
    ; For what ever comes after the tokens
    var %dend $MAKETOKCOUNT

    return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
  }

  UNMAKETOK
}
;;;;;;;;;;;;;;;;;;
; End Class body ;
;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;
; Helper Functions ;
;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Returns whether or not a class member ;
; is public.                                         ;
;                                                    ;
; Usage: $IsPublic(<Class>,<Member>)                 ;
; Example: if ($IsInstanceOf(%Player,Player)) ..     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias IsPublic return $isalias($+($1.,$2.,PUBLIC))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Returns whether or not an instance    ;
; exists in memory                                   ;
;                                                    ;
; Usage: $IsInstance(<Instance>)                     ;
; Example: if (!$IsInstance(%x)) %x = $Player        ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias IsClass return $isalias($1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Called from the class constructor to  ;
; let the object know that the specified object      ;
; inherits from the specified class                  ;
;                                                    ;
; Usage: $InheritsFrom(<Object>,<Class>)             ;
; Example: $InheritsFrom(%instance,Player)           ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias InheritsFrom hadd -m MSL++ $+($1_,INIT) $2 $hget(MSL++,$+($1_,INIT))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Returns whether or not an instance is ;
; an instance of the specified class                 ;
;                                                    ;
; Usage: $IsInstanceOf(<Instance>,<Class>)           ;
; Example: if ($IsInstanceOf(%Player,Player)) ..     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias IsInstanceOf return $istok($hget(MSL++,$1_INIT),$2,32)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Returns whether or not an instance    ;
; exists in memory                                   ;
;                                                    ;
; Usage: $IsInstance(<Instance>)                     ;
; Example: if (!$IsInstance(%x)) %x = $Player        ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias IsInstance return $token($hget(MSL++, $1_INIT),$iif($2 != $null,$2,1),32)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Used to call the first found method   ;
; associated with an objects inheritance tree...     ;
;                                                    ;
; Usage: $Object(<Instance>,..).<Method>             ;
; Example: $Object(%stack,$2).add                    ;
; Equivelent: $List(%stack,$2).add                   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias OBJECT {
  var %object $1
  var %inheritance $hget(MSL++,$+(%object,_,INIT))
  var %iterator 1
  if $mprop($prop) {
    while $token(%inheritance,%iterator,32) {
      var %currentClass $v1
      if $IsPublic(%currentClass,$fprop($mprop($prop))) {
        var %astart $MAKETOKCOUNT
        MAKETOK %currentClass
        MAKETOK $+($mprop($prop),$chr(58),IS_OBJECT_CALL,$iif($mprop($prop,1),. $+ $v1))
        MAKETOK %object
        var %aend $MAKETOKCOUNT

        var %bstart $MAKETOKCOUNT
        var %bend $MAKETOKCOUNT

        var %cstart $MAKETOKCOUNT + 1
        MAKETOK $*
        var %cend $MAKETOKCOUNT

        var %dstart $MAKETOKCOUNT
        ; For what ever comes after the tokens
        var %dend $MAKETOKCOUNT

        return $objecteval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)

      }
      inc %iterator
    }
    UNMAKETOK
    return $catch(Class,NoOperation,$scriptline, $token($token($script,-1,92),1,46), there is no function $qt($mprop($prop)) in object $qt(%object) $+ 's class heirarchy)
  }
  else {
    UNMAKETOK
    return $catch(%object,NoOperation,$scriptline, $token($token($script,-1,92),1,46),there is no operation specified for this object call!)
  }
  UNMAKETOK
  return $catch(%object,MemberErr,$scriptline, $token($token($script,-1,92),1,46),$qt($mprop($prop)) is not a public member of class $qt(Class))
}
;;;;;;;;;;;;;;
; End Object ;
;;;;;;;;;;;;;;
alias cprop {
  return $istok($1,$$2,58)
}
alias mprop {
  return $iif($2,$token($1,2-,46),$token($1,1,46))
}
alias fprop {
  return $token($1,$iif($2,$2,1),58)
}

alias MAKETOK {
  hinc -m MAKETOK COUNT
  hadd MAKETOK $hget(MAKETOK,COUNT) $1-
}
alias MAKETOKCOUNT {
  if $hget(MAKETOK,COUNT) {
    return $v1
  }
  else {
    return 0
  }
}
alias UNMAKETOK {
  if ($hget(MAKETOK)) hfree MAKETOK
}
alias GETMAKETOK {
  return $hget(MAKETOK, $1)
}

alias -l objecteval {
  var %astart $1
  var %aend $2
  var %acount %aend - %astart

  var %bstart $3
  var %bend $4
  var %bcount %bend - %bstart

  var %cstart $5 - 1
  var %cend $$6
  var %ccount %cend - %cstart

  var %dstart $7
  var %dend $8
  var %dcount %dend - %dstart

  var %localVariables

  var %x 1
  while %x <= %acount {
    var %y %x + %astart
    var %localVariables %localVariables $+ $chr(255) $+ $ $+ getmaketok $+ [ ( ] $+ %y $+ [ ) ]
    inc %x
  }

  tokenize 255 %localVariables

  var %class [ [ $1 ] ]
  var %prop [ [ $2 ] ]
  var %object [ [ $3 ] ]
  var %isObjectCall [ [ $4 ] ]

  var %header,%footer,%body

  var %x 1
  while %x <= %bcount {
    var %y %x + %bstart
    var %header %header $+ $chr(255) $+ $ $+ getmaketok $+ [ ( ] $+ %y $+ [ ) ]
    inc %x
  }

  var %x 1
  while %x <= %ccount {
    var %y %x + %cstart
    var %body %body $+ $chr(255) $+ $ $+ getmaketok $+ [ ( ] $+ %y $+ [ ) ]
    inc %x
  }

  var %x 1
  while %x <= %dcount {
    var %y %x + %dstart
    var %footer %footer $+ $chr(255) $+ $ + getmaketok $+ [ ( ] $+ %y $+ [ ) ]
  }

  var %eval,%endeval

  ;;var %eval $ $+ %class $+ . $+ $fprop($mprop(%prop)) $+ [ ( ] $+ [ $fprop($mprop(%prop),2-) ] $+ [ , ]
  ;;var %endeval [ ) ] $+ . $+ [ $mprop(%prop,1) ]

  ;;;;;;;;;;;;;;;
  if !%isObjectCall {
    if $isPublic(%class,$fprop($mprop(%prop))) || ($isPrivate(%class,$fprop($mprop(%prop))) && $fprop($mprop(%prop)) == INIT) {
      var %eval $ $+ %class $+ [ ( ] $+ 
      var %endeval [ ) ] $+ . $+ %prop
    }
    else {
      if ($IsInstance(%obejct))  {
        UNMAKETOK
        return $catch(%object, NoOperation, $scriptline, $token($token($script,-1,96),1,46), $qt($fprop($mprop(%prop))) is not a public member of class $qt(%class))
      }
      else {
        UNMAKETOK
        return $catch(Class, NoOperation, $scriptline, $token($token($script,-1,96),1,46), $qt($fprop($mprop(%prop))) is not a public member of class $qt(%class)).class
      }
    }
  }
  else {
    var %eval $ $+ OBJECT $+ [ ( ]
    var %endeval [ ) ] $+ . $+ $prop
  }
  ;;;;;;;;;;;;;;;;;

  tokenize 255 %header $+ %body $+ %footer

  var %x 1
  while %x <= $0 {
    if %x == $0 {
      var %eval %eval $+ [ $ $+ [ %x ] ]
    }
    else {
      var %eval %eval $+ [ $ $+ [ %x ] ] $+ [ , ]
    }
    inc %x
  }  
  ;echo -a EVAL: %eval $+ %endeval
  return [ [ %eval ] $+ [ %endeval ] ]
}
;;;;;;;;;;;;;;;;;;;;;;;;
; END HELPER FUNCTIONS ;
;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;
; Class Footer ;
;;;;;;;;;;;;;;;;
alias -l - { !noop $1- }
alias -l + { $iif($Window(@Debug),echo @Debug,!noop) $iif($1-,$v1,$crlf) }

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Returns whether or not a class member ;
; is private.                                        ;
;                                                    ;
; Usage: $IsPrivate(<Class>,<Member>)                ;
; Example: if ($IsInstanceOf(%Player,Player)) ..     ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias -l IsPrivate return $iif($IsClass($1) && $isalias($+($1.,$2)),$true,$false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Returns whether or not a class member ;
; is an exception.                                   ;
;                                                    ;
; Usage: $IsException(<Class>,<Member>)              ;
; Example: if ($IsExceptiion(%class,Null)) ..        ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias -l IsException return $iif($isalias($+($1,.EXCEPTION.,$$2)),$true,$false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code for passing dynamic variables to the $meval function ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;      var %astart $MAKETOKCOUNT         ; For passing variables to the $meval function (or your own function)                      ;
;      MAKETOK ClassName                           ;                                                                                          ;
;      MAKETOK $prop                               ;                                                                                          ;
;      var %aend $MAKETOKCOUNT           ;                                                                                          ;
;                                                            ;                                                                                          ;
;      var %bstart $MAKETOKCOUNT         ; For passing variables before the $N- tokens are passed (any number of variables allowed  ;
;      MAKETOK SomeValue                           ;    these variables will be before the $N- tokens.                                        ;
;      MAKETOK SomeValue2                          ;                                                                                          ;
;      var %bend $MAKETOKCOUNT           ;                                                                                          ;
;                                                            ;                                                                                          ;
;      var %cstart $MAKETOKCOUNT + 1      ; Starting token number (if trying to pass $2- to a function you put + 2 instead of  +1    ; 
;      MAKETOK $*                                  ;    (which is for tokens $1-)                                                             ;
;      var %cend $MAKETOKCOUNT            ;                                                                                          ;
;                                                           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;             
;      return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend) ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias -l meval {
  var %astart $1
  var %aend $2
  var %acount %aend - %astart

  var %bstart $3
  var %bend $4
  var %bcount %bend - %bstart

  var %cstart $5 - 1
  var %cend $$6
  var %ccount %cend - %cstart

  var %dstart $7
  var %dend $8
  var %dcount %dend - %dstart

  var %localVariables

  var %x 1
  while %x <= %acount {
    var %y %x + %astart
    var %localVariables %localVariables $+ $chr(255) $+ $ $+ getmaketok $+ [ ( ] $+ %y $+ [ ) ]
    inc %x
  }

  tokenize 255 %localVariables

  var %class [ [ $1 ] ]
  var %prop [ [ $2 ] ]
  var %object [ [ $3 ] ]
  var %isObjectCall [ [ $4 ] ]

  var %header,%footer,%body

  var %x 1
  while %x <= %bcount {
    var %y %x + %bstart
    var %header %header $+ $chr(255) $+ $ $+ getmaketok $+ [ ( ] $+ %y $+ [ ) ]
    inc %x
  }

  var %x 1
  while %x <= %ccount {
    var %y %x + %cstart
    var %body %body $+ $chr(255) $+ $ $+ getmaketok $+ [ ( ] $+ %y $+ [ ) ]
    inc %x
  }

  var %x 1
  while %x <= %dcount {
    var %y %x + %dstart
    var %footer %footer $+ $chr(255) $+ $ + getmaketok $+ [ ( ] $+ %y $+ [ ) ]
  }

  var %eval,%endeval

  ;;var %eval $ $+ %class $+ . $+ $fprop($mprop(%prop)) $+ [ ( ] $+ [ $fprop($mprop(%prop),2-) ] $+ [ , ]
  ;;var %endeval [ ) ] $+ . $+ [ $mprop(%prop,1) ]

  ;;;;;;;;;;;;;;;
  if !%isObjectCall {
    if $isPublic(%class,$fprop($mprop(%prop))) || ($isPrivate(%class,$fprop($mprop(%prop))) && $fprop($mprop(%prop)) == INIT) {
      var %eval $ $+ %class $+ . $+ $fprop($mprop(%prop)) $+ [ ( ] $+ $fprop($mprop(%prop),2-) $+ [ , ]
      var %endeval [ ) ] $+ . $+ [ $mprop(%prop,1) ]
    }
    else if $IsException(%class, $fprop($mprop(%prop))) {
      var %eval $ $+ %class $+ .EXCEPTION. $+ $fprop($mprop(%prop)) $+ [ ( ] $+ $fprop($mprop(%prop),2-) $+ [ , ]
      var %endeval [ ) ] $+ . $+ $mprop(%prop,1)
    }
    else {
      if ($IsInstance(%obejct))  {
        UNMAKETOK
        return $catch(%object, NoOperation, $scriptline, $token($token($script,-1,96),1,46), $qt($fprop($mprop(%prop))) is not a public member of class $qt(%class))
      }
      else {
        UNMAKETOK
        return $catch(Class, NoOperation, $scriptline, $token($token($script,-1,96),1,46), $qt($fprop($mprop(%prop))) is not a public member of class $qt(%class)).class
      }
    }
  }
  else {
    var %eval $ $+ OBJECT $+ [ ( ]
    var %endeval [ ) ] $+ . $+ $prop
  }
  ;;;;;;;;;;;;;;;;;

  tokenize 255 %header $+ %body $+ %footer

  var %x 1
  while %x <= $0 {
    if %x == $0 {
      var %eval %eval $+ [ $ $+ [ %x ] ]
    }
    else {
      var %eval %eval $+ [ $ $+ [ %x ] ] $+ [ , ]
    }
    inc %x
  }  
  return [ [ %eval ] $+ [ %endeval ] ]
}
;;;;;;;;;;;;;
; End meval ;
;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Called when ever an error is caught   ;
;                                                    ;
; Usage: $catch(<Instance>,<Error>,<Message>)        ;
; Example: if (!$IsInstanceOf(%Player,Player)) {     ;
; $catch(%Player,InstanceErr,Object %player is not   ;
;  an instance of class Player)                      ;
; }                                                  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
alias -l CATCH {
  var %error $2,%message $5,%instanceOrClass $1,%scriptLine $3, %scriptDir $4, %isClass $iif($mprop($prop) == class, $true,$false)

  if $isInstance(%instanceOrClass) && !%isClass {
    var %x 1
    var %inheritance $hget(MSL++,$+(%instanceOrClass,_,INIT))
    while $token(%inheritance,%x,32) {
      var %currentClass $v1
      if $IsException(%currentClass,%error) {
        var %astart $MAKETOKCOUNT
        MAKETOK %currentClass
        MAKETOK $+(%error,:,$token($token($script,-1,92),1,46),.,$prop)
        MAKETOK %instanceOrClass
        var %aend $MAKETOKCOUNT

        var %bstart $MAKETOKCOUNT
        var %bend $MAKETOKCOUNT

        var %cstart $MAKETOKCOUNT + 1
        MAKETOK $*
        var %cend $MAKETOKCOUNT

        var %dstart $MAKETOKCOUNT
        ; For what ever comes after the tokens
        var %dend $MAKETOKCOUNT

        return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
      }
      inc %x
    }
  }
  else if %isClass && $isClass(%instanceOrClass) {
    if $IsException(%instanceOrClass,%error) {
      var %astart $MAKETOKCOUNT
      MAKETOK %instanceOrClass
      MAKETOK $+(%error,:,$token($token($script,-1,92),1,46),.,$mprop($prop,1))
      var %aend $MAKETOKCOUNT

      var %bstart $MAKETOKCOUNT
      var %bend $MAKETOKCOUNT

      var %cstart $MAKETOKCOUNT + 1
      MAKETOK $*
      var %cend $MAKETOKCOUNT

      var %dstart $MAKETOKCOUNT
      ; For what ever comes dynamic set of paramters that come after the tokens
      var %dend $MAKETOKCOUNT

      return $meval(%astart,%aend,%bstart,%bend,%cstart,%cend,%dstart,%dend)
    }
  }
  UNMAKETOK
}
;;;;;;;;;;;;;
; End Catch ;
;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;
; END CLASS FOOTER ;
;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; mSL++ Class Downloader and Installer ;
; code...                               ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
dialog -l mslPlusPlusDownloaderAndInstaller {
  title "mSL++ Downloader and Installer"
  size -1 -1 340 256
  option dbu
  list 1, 3 13 203 72, size
  text List of mSL++ Classes not Installed, 7, 4 4 201 9, center
  button "Download", 3, 2 147 202 12
  text List of mSL++ Classes Installed, 10, 4 161 333 10, center
  button "Uninstall", 6, 4 243 333 12
  edit "", 4, 206 13 131 145
  text "Class Information", 9, 208 4 129 9, center
  text "Classes Dependant on Selected Class not Installed that are not Installed", 8, 3 86 202 8, center
  list 2, 3 96 202 50, size
  list 5, 3 171 335 72, size
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; End mSL++ Class Downlaoder and Installer ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;
; Triggers ;
;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; START                                   ;
;                                         ;
; Make sure all of the objects from the-  ;
; previous instance of MIRC get loaded    ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
on 1:start: {
  if (!$window(@DEBUG)) window -e @DEBUG

  var %objectDir $mircdir $+ MSL++
  var %objectsFile $+(%objectDir,\,MSL++.main)

  if ($exists(%objectsFile)) {
    hmake MSL++
    .hload -b MSL++ %objectsFile
    var %numberOfItems $hget(MSL++, 0).item
    var %x 1
    while (%x <= %numberOfItems) {
      var %currentObject $hget(MSL++, %x).item

      if ($right(%currentObject,5) == _INIT) {
        var %object $left(%currentObject,-5)

        if $exists($+(%objectDir,\,%object,.obj)) {
          + $Class(%object).IMPORT
        }
      }
      inc %x
    } 
  }
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; EXIT                                     ;
;                                          ;
; Make sure all of the objects from memory ;
; get exported before mIRC closes          ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
on 1:exit: {
  .ExportAllObjects
}

alias ExportAllObjects {
  var %objectDir $mircdir $+ MSL++
  if !$exists(%objectDir) { mkdir %objectDir }
  if ($hget(MSL++)) {
    .hsave -b MSL++ $+(%objectDir,\,MSL++ $+ .main)
    var %numberOfItems $hget(MSL++, 0).item
    var %x 1

    while (%x <= %numberOfItems) {
      var %currentObject $hget(MSL++,%x).item
      if $right(%currentObject,5) == _INIT {
        var %object $hget($left(%currentObject,-5))

        if (%object != $null) {
          + $Class(%object).EXPORT
        }
      }
      inc %x
    }
  }
}
;;;;;;;;;;;;;;;;
; END TRIGGERS ;
;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;
; DEPRECATED ;
;;;;;;;;;;;;;;
;alias objecteval2 {
;  var %tokentable $1
;
;  var %astart $2 + 1
;  var %aend $3
;  var %acount $calc(%aend - %astart + 1)
;
;  var %bstart $4 + 1
;  var %bend $5
;  var %bcount $calc(%bend - %bstart + 1)
;
;  var %cstart $6
;  var %cend $$7
;  var %ccount $calc(%cend - %cstart + 1)
;
;  var %aregex $regsubex($str(.,%acount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %astart - 1),$chr(41),$chr(58)))
;  var %bregex $regsubex($str(.,%bcount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %bstart - 1),$chr(41),$chr(58)))
;  var %cregex $regsubex($str(.,%ccount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %cstart - 1),$chr(41),$chr(58)))
;
;  tokenize 58 %aregex
;
;  var %class [ [ $1 ] ]
;  var %prop [ [ $2 ] ]
;  var %object [ [ $3 ] ]
;  var %isObjectCall [ [ $4 ] ]
;
;  if !%isObjectCall {
;    if $isPublic(%class,$fprop($mprop(%prop))) || ($isPrivate(%class,$fprop($mprop(%prop))) && $fprop($mprop(%prop)) == INIT) {
;      var %regex $+($,%class,$chr(40), $left($replace(%bregex %cregex,$chr(58),$chr(32) $chr(44) $chr(32)),-5),$chr(41),$iif(%prop,$+(.,$v1)))
;      return [ [ %regex ] ]
;    }
;     else if $IsException(%class, $fprop($mprop(%prop))) {
;      var %regex $+($,%class,.EXCEPTION.,$$fprop($mprop(%prop)),$chr(40),$fprop($mprop(%prop),2-),$chr(44),$left($replace(%bregex %cregex,$chr(58),$chr(32) $chr(44) $chr(32)),-5),$chr(41),$iif(!$IsInstance(%object),.CLASS))
;      + %REGEX REGEX
;      return [ [ %regex ] ]
;    }
;    else {
;      if $isInstance(%object) {
;        return $catch(%object,MemberErr, $scriptline, $token($token($script,-1,92),1,46), $qt($fprop($mprop(%prop))) is not a public member of %Class)
;      }
;      else {
;        return $catch(%class, MemberErr, $scriptline, $token($token($script,-1,92),1,46), $qt($fprop($mprop(%prop))) is not a public member of %Class).class
;      }
;    }
;  }
;  else {
;    var %regex $+($,OBJECT,$chr(40),$left($replace(%bregex %cregex,$chr(58),$chr(32) $chr(44) $chr(32)),-5),$chr(41),$iif(%prop,$+(.,$v1)))
;    return [ [ %regex ] ]
;  }
;  if $isInstance(%object) {
;    return $catch(%object,MemberErr, $scriptline, $token($token($script,-1,92),1,46), $qt($fprop($mprop(%prop))) is not a public member of %Class)
;  }
;  else {
;    return $catch(%class, MemberErr, $scriptline, $token($token($script,-1,92),1,46), $qt($fprop($mprop(%prop))) is not a public member of %Class).class
;  }
;}
;alias -l meval {
;  var %tokentable $1;
;
;  var %astart $2 + 1
;  var %aend $3
;  var %acount $calc(%aend - %astart + 1);;
;
;  var %bstart $4 + 1
;  var %bend $5
;  var %bcount $calc(%bend - %bstart + 1)
;
;  var %cstart $6
;  var %cend $$7
;  var %ccount $calc(%cend - %cstart + 1)
;
;  var %aregex $regsubex($str(.,%acount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %astart - 1),$chr(41),$chr(58)))
;  var %bregex $regsubex($str(.,%bcount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %bstart - 1),$chr(41),$chr(58)))
;  var %cregex $regsubex($str(.,%ccount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %cstart - 1),$chr(41),$chr(58)))
;
;  tokenize 58 %aregex
;
;  var %class [ [ $1 ] ]
;  var %prop [ [ $2 ] ]
;  var %object [ [ $3 ] ]
;  var %isObjectCall [ [ $4 ] ]
;
;  if !%isObjectCall {
;   if $isPublic(%class,$fprop($mprop(%prop))) || ($isPrivate(%class,$fprop($mprop(%prop))) && $fprop($mprop(%prop)) == INIT) {
;     var %regex $+($,%class,.,$fprop($mprop(%prop)),$chr(40),$iif($fprop($mprop(%prop),2-),$v1 $+ $chr(44),$null $+ $chr(44)), $left($replace(%bregex %cregex,$chr(58),$chr(32) $chr(44) $chr(32)),-5),$chr(41),$iif($mprop(%prop,1),$+(.,$v1)))
;
;
;
;      return [ [ %regex ] ]
;    }
;    else if $IsException(%class, $fprop($mprop(%prop))) {
;      var %regex $+($,%class,.,EXCEPTION.,$fprop($mprop(%prop)),$chr(40),$iif($fprop($mprop(%prop),2-),$v1 $+ $chr(44),$null $+ $chr(44)), $left($replace(%bregex %cregex,$chr(58),$chr(32) $chr(44) $chr(32)),-5),$chr(41),$iif($mprop(%prop,1),$+(.,$v1)))
;      return [ [ %regex ] ]
;    }
;  }
;  else {
;    var %regex $+($,OBJECT,$chr(40),$left($replace(%bregex %cregex,$chr(58),$chr(32) $chr(44) $chr(32)),-5),$chr(41),$iif(%prop,$+(.,$v1)))
;    return [ [ %regex ] ]
;  }
;  ;;;;unreachable code
;  if $isInstance(%object) {
;    return $catch(%object,MemberErr, $scriptline, $token($token($script,-1,92),1,46), $qt($fprop($mprop(%prop))) is not a public member of %Class)
;  }
;  else {
;    return $catch(%class, MemberErr, $scriptline, $token($token($script,-1,92),1,46), $qt($fprop($mprop(%prop))) is not a public member of %Class).class
;  }
;}
;alias -l catcheval {
;  var %tokentable $1
;
;  var %astart $2 + 1
;  var %aend $3
;  var %acount $calc(%aend - %astart + 1)
;
;  var %bstart $4 + 1
;  var %bend $5
;  var %bcount $calc(%bend - %bstart + 1)
;
;  var %cstart $6
;  var %cend $$7
;  var %ccount $calc(%cend - %cstart + 1)
;
;  var %aregex $regsubex($str(.,%acount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %astart - 1),$chr(41),$chr(58)))
;  var %bregex $regsubex($str(.,%bcount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %bstart - 1),$chr(41),$chr(58)))
;  var %cregex $regsubex($str(.,%ccount),/(.)/g,$+($,hget,$chr(40),%tokentable,$chr(44),$calc(\n + %cstart - 1),$chr(41),$chr(58)))
;
;  tokenize 58 %aregex
;
;  var %class [ [ $1 ] ]
;  var %prop [ [ $2 ] ]
;  var %object [ [ $3 ] ]
;  var %script [ [ $4 ] ]
;
;  if $IsException(%class, $fprop($mprop(%prop))) {
;    var %regex $+($,%class,.EXCEPTION.,$fprop($mprop(%prop)),$chr(40),$+(%script,$iif($fprop($mprop(%prop),2-),: $+ $v1)),$chr(44),$left($replace(%bregex %cregex,$chr(58),$chr(32) $chr(44) $chr(32)),-5),$chr(41),$iif(!$IsInstance(%object),.CLASS))
;    - %REGEX REGEX
;    return [ [ %regex ] ]
;  }
;}
